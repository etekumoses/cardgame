/**
  * react-collapsed
  *
  * Copyright (c) 2019-2022, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => useCollapse
});
module.exports = __toCommonJS(src_exports);

// src/useCollapse.ts
var import_react2 = require("react");

// src/utils.ts
var React = __toESM(require("react"));
var import_react = require("react");
var import_tiny_warning = __toESM(require("tiny-warning"));
var callAll = (...fns) => (...args) => fns.forEach((fn) => fn && fn(...args));
function getAutoHeightDuration(height) {
  if (!height || typeof height === "string") {
    return 0;
  }
  const constant = height / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(`Cannot assign value "${value}" to ref "${ref}"`);
    }
  }
}
function mergeRefs(...refs) {
  if (refs.every((ref) => ref == null)) {
    return null;
  }
  return (node) => {
    refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}
function useEvent(callback) {
  const ref = (0, import_react.useRef)(callback);
  (0, import_react.useEffect)(() => {
    ref.current = callback;
  });
  return (0, import_react.useCallback)((...args) => {
    var _a;
    return (_a = ref.current) == null ? void 0 : _a.call(ref, ...args);
  }, []);
}
function useControlledState(value, defaultValue, callback) {
  const [state, setState] = (0, import_react.useState)(defaultValue);
  const initiallyControlled = (0, import_react.useRef)(typeof value !== "undefined");
  const effectiveValue = initiallyControlled.current ? value : state;
  const cb = useEvent(callback);
  const onChange = (0, import_react.useCallback)(
    (update) => {
      const setter = update;
      const newValue = typeof update === "function" ? setter(effectiveValue) : update;
      if (!initiallyControlled.current) {
        setState(newValue);
      }
      cb == null ? void 0 : cb(newValue);
    },
    [cb, effectiveValue]
  );
  (0, import_react.useEffect)(() => {
    (0, import_tiny_warning.default)(
      !(initiallyControlled.current && value == null),
      "useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."
    );
    (0, import_tiny_warning.default)(
      !(!initiallyControlled.current && value != null),
      "useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."
    );
  }, [value]);
  return [effectiveValue, onChange];
}
var useLayoutEffect2 = typeof window !== "undefined" ? React.useLayoutEffect : import_react.useEffect;
function paddingWarning(element) {
  if (true !== "production") {
    if (window && "getComputedStyle" in window) {
      const { paddingTop, paddingBottom } = window.getComputedStyle(element);
      const hasPadding = paddingTop && paddingTop !== "0px" || paddingBottom && paddingBottom !== "0px";
      (0, import_tiny_warning.default)(
        !hasPadding,
        "Collapse: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element."
      );
    }
  }
}
var generateUID = () => {
  let counter = 1;
  const map = /* @__PURE__ */ new WeakMap();
  const uid2 = (item, index) => {
    if (typeof item === "number" || typeof item === "string") {
      return index ? `idx-${index}` : `val-${item}`;
    }
    if (!map.has(item)) {
      map.set(item, counter++);
      return uid2(item);
    }
    return "uid" + map.get(item);
  };
  return uid2;
};
var uid = generateUID();

// src/Collapse.ts
var Collapse = class {
  constructor(params) {
    __publicField(this, "isExpanded");
    __publicField(this, "options");
    __publicField(this, "id");
    __publicField(this, "collapseElement", null);
    __publicField(this, "isMounted", false);
    __publicField(this, "init", () => {
      const collapseElement = this.options.getCollapseElement();
      if (this.collapseElement !== collapseElement) {
        this.collapseElement = collapseElement;
        if (!this.isExpanded) {
          this.setStyles(this.getCollapsedStyles());
        }
      }
    });
    __publicField(this, "getCollapsedStyles", () => {
      return {
        display: this.options.collapsedHeight === 0 ? "none" : "block",
        height: `${this.options.collapsedHeight}px`,
        overflow: "hidden"
      };
    });
    __publicField(this, "setOptions", (update) => {
      var _a;
      const opts = typeof update === "function" ? update(this.options) : update;
      Object.entries(opts).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts[key];
      });
      this.options = __spreadValues({
        duration: "auto",
        easing: "cubic-bezier(0.4, 0, 0.2, 1)",
        expandStyles: {},
        collapseStyles: {},
        hasDisabledAnimation: false,
        collapsedHeight: 0,
        defaultExpanded: false,
        onExpandedChange() {
        }
      }, opts);
      this.id = (_a = this.options.id) != null ? _a : `collapse-${uid(this)}`;
    });
    __publicField(this, "setStyles", (styles) => {
      const target = this.options.getCollapseElement();
      if (!target) {
        return;
      }
      for (const property in styles) {
        const value = styles[property];
        if (value) {
          target.style[property] = value;
        } else {
          target.style.removeProperty(property);
        }
      }
    });
    __publicField(this, "getTransitionStyles", (height) => {
      if (this.options.hasDisabledAnimation) {
        return "";
      }
      const duration = this.options.duration === "auto" ? getAutoHeightDuration(height) : this.options.duration;
      return `height ${duration}ms ${this.options.easing}`;
    });
    __publicField(this, "handleTransitionEnd", (e) => {
      var _a, _b, _c, _d;
      if (e.propertyName !== "height") {
        return;
      }
      if (this.isExpanded) {
        this.setStyles({
          height: "",
          overflow: "",
          transition: "",
          display: ""
        });
        (_b = (_a = this.options).onExpandEnd) == null ? void 0 : _b.call(_a);
      } else {
        this.setStyles(__spreadProps(__spreadValues({}, this.getCollapsedStyles()), {
          transition: ""
        }));
        (_d = (_c = this.options).onCollapseEnd) == null ? void 0 : _d.call(_c);
      }
    });
    __publicField(this, "open", () => {
      var _a, _b, _c, _d;
      if (this.isExpanded || !this.isMounted) {
        return;
      }
      const target = this.options.getCollapseElement();
      if (!target) {
        return;
      }
      this.isExpanded = true;
      (_b = (_a = this.options).onExpandedChange) == null ? void 0 : _b.call(_a, true);
      (_d = (_c = this.options).onExpandStart) == null ? void 0 : _d.call(_c);
      paddingWarning(target);
      requestAnimationFrame(() => {
        this.setStyles(__spreadProps(__spreadValues({}, this.options.expandStyles), {
          display: "block",
          overflow: "hidden",
          height: `${this.options.collapsedHeight}px`
        }));
        requestAnimationFrame(() => {
          const height = target.scrollHeight;
          target.style.transition = this.getTransitionStyles(height);
          target.style.height = `${height}px`;
        });
      });
    });
    __publicField(this, "close", () => {
      var _a, _b, _c, _d;
      if (!this.isExpanded) {
        return;
      }
      const target = this.options.getCollapseElement();
      if (!target) {
        return;
      }
      if (!this.isMounted) {
        this.init();
        return;
      }
      this.isExpanded = false;
      (_b = (_a = this.options).onExpandedChange) == null ? void 0 : _b.call(_a, false);
      (_d = (_c = this.options).onCollapseStart) == null ? void 0 : _d.call(_c);
      requestAnimationFrame(() => {
        const height = target.scrollHeight;
        this.setStyles(__spreadProps(__spreadValues({}, this.options.collapseStyles), {
          transition: this.getTransitionStyles(height),
          height: `${height}px`
        }));
        requestAnimationFrame(() => {
          this.setStyles({
            height: `${this.options.collapsedHeight}px`,
            overflow: "hidden"
          });
        });
      });
    });
    __publicField(this, "toggle", () => {
      if (this.isExpanded) {
        this.close();
      } else {
        this.open();
      }
    });
    __publicField(this, "getCollapse", () => {
      var _a, _b;
      const hasToggle = Boolean((_b = (_a = this.options).getToggleElement) == null ? void 0 : _b.call(_a));
      return {
        id: this.id,
        "aria-hidden": this.isExpanded ? void 0 : true,
        onTransitionEndHandler: this.handleTransitionEnd,
        style: {
          boxSizing: "border-box"
        },
        role: "region",
        "aria-labelledby": hasToggle ? `${this.id}-toggle` : void 0
      };
    });
    __publicField(this, "getToggle", ({ disabled } = { disabled: false }) => {
      var _a, _b;
      const toggleElement = (_b = (_a = this.options).getToggleElement) == null ? void 0 : _b.call(_a);
      const isButton = toggleElement ? toggleElement.tagName === "BUTTON" : false;
      const props = {
        onClickHandler: disabled ? () => {
        } : this.toggle,
        id: `${this.id}-toggle`,
        "aria-controls": this.id,
        "aria-expanded": this.isExpanded
      };
      if (isButton) {
        props.type = "button";
        props.disabled = disabled ? true : void 0;
      } else {
        props["aria-disabled"] = disabled ? true : void 0;
        props.role = "button";
        props.tabIndex = disabled ? -1 : 0;
      }
      return props;
    });
    this.setOptions(params);
    this.isExpanded = Boolean(this.options.defaultExpanded);
    this.init();
    this.isMounted = true;
  }
};

// src/useCollapse.ts
function useCollapse(options = {}) {
  const _a = options, {
    isExpanded: propExpanded,
    defaultExpanded: propDefaultExpanded,
    onExpandedChange
  } = _a, opts = __objRest(_a, [
    "isExpanded",
    "defaultExpanded",
    "onExpandedChange"
  ]);
  const id = (0, import_react2.useId)();
  const collapseEl = (0, import_react2.useRef)(null);
  const [toggleEl, setToggleEl] = (0, import_react2.useState)(null);
  const [isExpanded, setExpanded] = useControlledState(
    propExpanded,
    propDefaultExpanded,
    onExpandedChange
  );
  const resolvedOptions = __spreadProps(__spreadValues({
    id
  }, opts), {
    getCollapseElement: () => collapseEl.current,
    getToggleElement: () => toggleEl,
    defaultExpanded: isExpanded,
    onExpandedChange: setExpanded
  });
  const [instance] = (0, import_react2.useState)(() => new Collapse(resolvedOptions));
  instance.setOptions(resolvedOptions);
  useLayoutEffect2(() => {
    if (isExpanded) {
      instance.open();
    } else {
      instance.close();
    }
  }, [isExpanded, instance]);
  const assignRef2 = (node) => {
    if (collapseEl.current !== node) {
      collapseEl.current = node;
      if (!!node) {
        instance.init();
      }
    }
  };
  return {
    getCollapseProps(_b = {}) {
      var _c = _b, {
        refKey = "ref"
      } = _c, rest = __objRest(_c, [
        "refKey"
      ]);
      const theirRef = rest[refKey];
      if (!instance) {
        return { [refKey]: mergeRefs(theirRef, assignRef2) };
      }
      const _a2 = instance.getCollapse(), { onTransitionEndHandler } = _a2, props = __objRest(_a2, ["onTransitionEndHandler"]);
      return __spreadProps(__spreadValues(__spreadValues({}, rest), props), {
        [refKey]: mergeRefs(theirRef, assignRef2),
        onTransitionEnd: onTransitionEndHandler
      });
    },
    getToggleProps(_d = {}) {
      var _e = _d, {
        disabled,
        onClick = () => {
        },
        refKey = "ref"
      } = _e, rest = __objRest(_e, [
        "disabled",
        "onClick",
        "refKey"
      ]);
      const theirRef = rest[refKey];
      if (!instance) {
        return { [refKey]: mergeRefs(theirRef, setToggleEl) };
      }
      const _a2 = instance.getToggle({
        disabled
      }), { onClickHandler } = _a2, props = __objRest(_a2, ["onClickHandler"]);
      return __spreadProps(__spreadValues(__spreadValues({}, rest), props), {
        [refKey]: mergeRefs(theirRef, setToggleEl),
        onClick: callAll(onClickHandler, onClick)
      });
    },
    isExpanded,
    setExpanded
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.cjs.dev.js.map