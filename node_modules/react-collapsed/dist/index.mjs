/**
  * react-collapsed
  *
  * Copyright (c) 2019-2022, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/useCollapse.ts
import { useId, useState as useState2, useRef as useRef2 } from "react";

// src/utils.ts
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import warning from "tiny-warning";
var callAll = (...fns) => (...args) => fns.forEach((fn) => fn && fn(...args));
function getAutoHeightDuration(height) {
  if (!height || typeof height === "string") {
    return 0;
  }
  const constant = height / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(`Cannot assign value "${value}" to ref "${ref}"`);
    }
  }
}
function mergeRefs(...refs) {
  if (refs.every((ref) => ref == null)) {
    return null;
  }
  return (node) => {
    refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}
function useEvent(callback) {
  const ref = useRef(callback);
  useEffect(() => {
    ref.current = callback;
  });
  return useCallback((...args) => ref.current?.(...args), []);
}
function useControlledState(value, defaultValue, callback) {
  const [state, setState] = useState(defaultValue);
  const initiallyControlled = useRef(typeof value !== "undefined");
  const effectiveValue = initiallyControlled.current ? value : state;
  const cb = useEvent(callback);
  const onChange = useCallback(
    (update) => {
      const setter = update;
      const newValue = typeof update === "function" ? setter(effectiveValue) : update;
      if (!initiallyControlled.current) {
        setState(newValue);
      }
      cb?.(newValue);
    },
    [cb, effectiveValue]
  );
  useEffect(() => {
    warning(
      !(initiallyControlled.current && value == null),
      "useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."
    );
    warning(
      !(!initiallyControlled.current && value != null),
      "useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."
    );
  }, [value]);
  return [effectiveValue, onChange];
}
var useLayoutEffect2 = typeof window !== "undefined" ? React.useLayoutEffect : useEffect;
function paddingWarning(element) {
  if (true !== "production") {
    if (window && "getComputedStyle" in window) {
      const { paddingTop, paddingBottom } = window.getComputedStyle(element);
      const hasPadding = paddingTop && paddingTop !== "0px" || paddingBottom && paddingBottom !== "0px";
      warning(
        !hasPadding,
        "Collapse: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element."
      );
    }
  }
}
var generateUID = () => {
  let counter = 1;
  const map = /* @__PURE__ */ new WeakMap();
  const uid2 = (item, index) => {
    if (typeof item === "number" || typeof item === "string") {
      return index ? `idx-${index}` : `val-${item}`;
    }
    if (!map.has(item)) {
      map.set(item, counter++);
      return uid2(item);
    }
    return "uid" + map.get(item);
  };
  return uid2;
};
var uid = generateUID();

// src/Collapse.ts
var Collapse = class {
  constructor(params) {
    __publicField(this, "isExpanded");
    __publicField(this, "options");
    __publicField(this, "id");
    __publicField(this, "collapseElement", null);
    __publicField(this, "isMounted", false);
    __publicField(this, "init", () => {
      const collapseElement = this.options.getCollapseElement();
      if (this.collapseElement !== collapseElement) {
        this.collapseElement = collapseElement;
        if (!this.isExpanded) {
          this.setStyles(this.getCollapsedStyles());
        }
      }
    });
    __publicField(this, "getCollapsedStyles", () => {
      return {
        display: this.options.collapsedHeight === 0 ? "none" : "block",
        height: `${this.options.collapsedHeight}px`,
        overflow: "hidden"
      };
    });
    __publicField(this, "setOptions", (update) => {
      const opts = typeof update === "function" ? update(this.options) : update;
      Object.entries(opts).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts[key];
      });
      this.options = {
        duration: "auto",
        easing: "cubic-bezier(0.4, 0, 0.2, 1)",
        expandStyles: {},
        collapseStyles: {},
        hasDisabledAnimation: false,
        collapsedHeight: 0,
        defaultExpanded: false,
        onExpandedChange() {
        },
        ...opts
      };
      this.id = this.options.id ?? `collapse-${uid(this)}`;
    });
    __publicField(this, "setStyles", (styles) => {
      const target = this.options.getCollapseElement();
      if (!target) {
        return;
      }
      for (const property in styles) {
        const value = styles[property];
        if (value) {
          target.style[property] = value;
        } else {
          target.style.removeProperty(property);
        }
      }
    });
    __publicField(this, "getTransitionStyles", (height) => {
      if (this.options.hasDisabledAnimation) {
        return "";
      }
      const duration = this.options.duration === "auto" ? getAutoHeightDuration(height) : this.options.duration;
      return `height ${duration}ms ${this.options.easing}`;
    });
    __publicField(this, "handleTransitionEnd", (e) => {
      if (e.propertyName !== "height") {
        return;
      }
      if (this.isExpanded) {
        this.setStyles({
          height: "",
          overflow: "",
          transition: "",
          display: ""
        });
        this.options.onExpandEnd?.();
      } else {
        this.setStyles({
          ...this.getCollapsedStyles(),
          transition: ""
        });
        this.options.onCollapseEnd?.();
      }
    });
    __publicField(this, "open", () => {
      if (this.isExpanded || !this.isMounted) {
        return;
      }
      const target = this.options.getCollapseElement();
      if (!target) {
        return;
      }
      this.isExpanded = true;
      this.options.onExpandedChange?.(true);
      this.options.onExpandStart?.();
      paddingWarning(target);
      requestAnimationFrame(() => {
        this.setStyles({
          ...this.options.expandStyles,
          display: "block",
          overflow: "hidden",
          height: `${this.options.collapsedHeight}px`
        });
        requestAnimationFrame(() => {
          const height = target.scrollHeight;
          target.style.transition = this.getTransitionStyles(height);
          target.style.height = `${height}px`;
        });
      });
    });
    __publicField(this, "close", () => {
      if (!this.isExpanded) {
        return;
      }
      const target = this.options.getCollapseElement();
      if (!target) {
        return;
      }
      if (!this.isMounted) {
        this.init();
        return;
      }
      this.isExpanded = false;
      this.options.onExpandedChange?.(false);
      this.options.onCollapseStart?.();
      requestAnimationFrame(() => {
        const height = target.scrollHeight;
        this.setStyles({
          ...this.options.collapseStyles,
          transition: this.getTransitionStyles(height),
          height: `${height}px`
        });
        requestAnimationFrame(() => {
          this.setStyles({
            height: `${this.options.collapsedHeight}px`,
            overflow: "hidden"
          });
        });
      });
    });
    __publicField(this, "toggle", () => {
      if (this.isExpanded) {
        this.close();
      } else {
        this.open();
      }
    });
    __publicField(this, "getCollapse", () => {
      const hasToggle = Boolean(this.options.getToggleElement?.());
      return {
        id: this.id,
        "aria-hidden": this.isExpanded ? void 0 : true,
        onTransitionEndHandler: this.handleTransitionEnd,
        style: {
          boxSizing: "border-box"
        },
        role: "region",
        "aria-labelledby": hasToggle ? `${this.id}-toggle` : void 0
      };
    });
    __publicField(this, "getToggle", ({ disabled } = { disabled: false }) => {
      const toggleElement = this.options.getToggleElement?.();
      const isButton = toggleElement ? toggleElement.tagName === "BUTTON" : false;
      const props = {
        onClickHandler: disabled ? () => {
        } : this.toggle,
        id: `${this.id}-toggle`,
        "aria-controls": this.id,
        "aria-expanded": this.isExpanded
      };
      if (isButton) {
        props.type = "button";
        props.disabled = disabled ? true : void 0;
      } else {
        props["aria-disabled"] = disabled ? true : void 0;
        props.role = "button";
        props.tabIndex = disabled ? -1 : 0;
      }
      return props;
    });
    this.setOptions(params);
    this.isExpanded = Boolean(this.options.defaultExpanded);
    this.init();
    this.isMounted = true;
  }
};

// src/useCollapse.ts
function useCollapse(options = {}) {
  const {
    isExpanded: propExpanded,
    defaultExpanded: propDefaultExpanded,
    onExpandedChange,
    ...opts
  } = options;
  const id = useId();
  const collapseEl = useRef2(null);
  const [toggleEl, setToggleEl] = useState2(null);
  const [isExpanded, setExpanded] = useControlledState(
    propExpanded,
    propDefaultExpanded,
    onExpandedChange
  );
  const resolvedOptions = {
    id,
    ...opts,
    getCollapseElement: () => collapseEl.current,
    getToggleElement: () => toggleEl,
    defaultExpanded: isExpanded,
    onExpandedChange: setExpanded
  };
  const [instance] = useState2(() => new Collapse(resolvedOptions));
  instance.setOptions(resolvedOptions);
  useLayoutEffect2(() => {
    if (isExpanded) {
      instance.open();
    } else {
      instance.close();
    }
  }, [isExpanded, instance]);
  const assignRef2 = (node) => {
    if (collapseEl.current !== node) {
      collapseEl.current = node;
      if (!!node) {
        instance.init();
      }
    }
  };
  return {
    getCollapseProps({
      refKey = "ref",
      ...rest
    } = {}) {
      const theirRef = rest[refKey];
      if (!instance) {
        return { [refKey]: mergeRefs(theirRef, assignRef2) };
      }
      const { onTransitionEndHandler, ...props } = instance.getCollapse();
      return {
        ...rest,
        ...props,
        [refKey]: mergeRefs(theirRef, assignRef2),
        onTransitionEnd: onTransitionEndHandler
      };
    },
    getToggleProps({
      disabled,
      onClick = () => {
      },
      refKey = "ref",
      ...rest
    } = {}) {
      const theirRef = rest[refKey];
      if (!instance) {
        return { [refKey]: mergeRefs(theirRef, setToggleEl) };
      }
      const { onClickHandler, ...props } = instance.getToggle({
        disabled
      });
      return {
        ...rest,
        ...props,
        [refKey]: mergeRefs(theirRef, setToggleEl),
        onClick: callAll(onClickHandler, onClick)
      };
    },
    isExpanded,
    setExpanded
  };
}
export {
  useCollapse as default
};
