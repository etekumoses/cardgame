{
  "version": 3,
  "sources": ["../../wavesurfer.js/dist/decoder.js", "../../wavesurfer.js/dist/fetcher.js", "../../wavesurfer.js/dist/event-emitter.js", "../../wavesurfer.js/dist/player.js", "../../wavesurfer.js/dist/draggable.js", "../../wavesurfer.js/dist/renderer.js", "../../wavesurfer.js/dist/timer.js", "../../wavesurfer.js/dist/wavesurfer.js"],
  "sourcesContent": ["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/** Decode an array buffer into an audio buffer */\nfunction decode(audioData, sampleRate) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const audioCtx = new AudioContext({ sampleRate });\n        const decode = audioCtx.decodeAudioData(audioData);\n        return decode.finally(() => audioCtx.close());\n    });\n}\n/** Normalize peaks to -1..1 */\nfunction normalize(channelData) {\n    const firstChannel = channelData[0];\n    if (firstChannel.some((n) => n > 1 || n < -1)) {\n        const length = firstChannel.length;\n        let max = 0;\n        for (let i = 0; i < length; i++) {\n            const absN = Math.abs(firstChannel[i]);\n            if (absN > max)\n                max = absN;\n        }\n        for (const channel of channelData) {\n            for (let i = 0; i < length; i++) {\n                channel[i] /= max;\n            }\n        }\n    }\n    return channelData;\n}\n/** Create an audio buffer from pre-decoded audio data */\nfunction createBuffer(channelData, duration) {\n    // If a single array of numbers is passed, make it an array of arrays\n    if (typeof channelData[0] === 'number')\n        channelData = [channelData];\n    // Normalize to -1..1\n    normalize(channelData);\n    return {\n        duration,\n        length: channelData[0].length,\n        sampleRate: channelData[0].length / duration,\n        numberOfChannels: channelData.length,\n        getChannelData: (i) => channelData === null || channelData === void 0 ? void 0 : channelData[i],\n        copyFromChannel: AudioBuffer.prototype.copyFromChannel,\n        copyToChannel: AudioBuffer.prototype.copyToChannel,\n    };\n}\nconst Decoder = {\n    decode,\n    createBuffer,\n};\nexport default Decoder;\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction fetchBlob(url, progressCallback, requestInit) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        // Fetch the resource\n        const response = yield fetch(url, requestInit);\n        // Read the data to track progress\n        {\n            const reader = (_a = response.clone().body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const contentLength = Number((_b = response.headers) === null || _b === void 0 ? void 0 : _b.get('Content-Length'));\n            let receivedLength = 0;\n            // Process the data\n            const processChunk = (done, value) => __awaiter(this, void 0, void 0, function* () {\n                if (done)\n                    return;\n                // Add to the received length\n                receivedLength += (value === null || value === void 0 ? void 0 : value.length) || 0;\n                const percentage = Math.round((receivedLength / contentLength) * 100);\n                progressCallback(percentage);\n                // Continue reading data\n                return reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));\n            });\n            reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));\n        }\n        return response.blob();\n    });\n}\nconst Fetcher = {\n    fetchBlob,\n};\nexport default Fetcher;\n", "/** A simple event emitter that can be used to listen to and emit events. */\nclass EventEmitter {\n    constructor() {\n        this.listeners = {};\n    }\n    /** Subscribe to an event. Returns an unsubscribe function. */\n    on(eventName, listener) {\n        if (!this.listeners[eventName]) {\n            this.listeners[eventName] = new Set();\n        }\n        this.listeners[eventName].add(listener);\n        return () => this.un(eventName, listener);\n    }\n    /** Subscribe to an event only once */\n    once(eventName, listener) {\n        // The actual subscription\n        const unsubscribe = this.on(eventName, listener);\n        // Another subscription that will unsubscribe the actual subscription and itself after the first event\n        const unsubscribeOnce = this.on(eventName, () => {\n            unsubscribe();\n            unsubscribeOnce();\n        });\n        return unsubscribe;\n    }\n    /** Unsubscribe from an event */\n    un(eventName, listener) {\n        if (this.listeners[eventName]) {\n            if (listener) {\n                this.listeners[eventName].delete(listener);\n            }\n            else {\n                delete this.listeners[eventName];\n            }\n        }\n    }\n    /** Clear all events */\n    unAll() {\n        this.listeners = {};\n    }\n    /** Emit an event */\n    emit(eventName, ...args) {\n        if (this.listeners[eventName]) {\n            this.listeners[eventName].forEach((listener) => listener(...args));\n        }\n    }\n}\nexport default EventEmitter;\n", "import EventEmitter from './event-emitter.js';\nclass Player extends EventEmitter {\n    constructor(options) {\n        super();\n        if (options.media) {\n            this.media = options.media;\n        }\n        else {\n            this.media = document.createElement('audio');\n        }\n        // Controls\n        if (options.mediaControls) {\n            this.media.controls = true;\n        }\n        // Autoplay\n        if (options.autoplay) {\n            this.media.autoplay = true;\n        }\n        // Speed\n        if (options.playbackRate != null) {\n            this.onceMediaEvent('canplay', () => {\n                if (options.playbackRate != null) {\n                    this.media.playbackRate = options.playbackRate;\n                }\n            });\n        }\n    }\n    onMediaEvent(event, callback, options) {\n        this.media.addEventListener(event, callback, options);\n        return () => this.media.removeEventListener(event, callback);\n    }\n    onceMediaEvent(event, callback) {\n        return this.onMediaEvent(event, callback, { once: true });\n    }\n    getSrc() {\n        return this.media.currentSrc || this.media.src || '';\n    }\n    revokeSrc() {\n        const src = this.getSrc();\n        if (src.startsWith('blob:')) {\n            URL.revokeObjectURL(src);\n        }\n    }\n    setSrc(url, blob) {\n        const src = this.getSrc();\n        if (src === url)\n            return;\n        this.revokeSrc();\n        const newSrc = blob instanceof Blob ? URL.createObjectURL(blob) : url;\n        this.media.src = newSrc;\n        this.media.load();\n    }\n    destroy() {\n        this.media.pause();\n        this.revokeSrc();\n        this.media.src = '';\n        // Load resets the media element to its initial state\n        this.media.load();\n    }\n    /** Start playing the audio */\n    play() {\n        return this.media.play();\n    }\n    /** Pause the audio */\n    pause() {\n        this.media.pause();\n    }\n    /** Check if the audio is playing */\n    isPlaying() {\n        return this.media.currentTime > 0 && !this.media.paused && !this.media.ended;\n    }\n    /** Jumpt to a specific time in the audio (in seconds) */\n    setTime(time) {\n        this.media.currentTime = time;\n    }\n    /** Get the duration of the audio in seconds */\n    getDuration() {\n        return this.media.duration;\n    }\n    /** Get the current audio position in seconds */\n    getCurrentTime() {\n        return this.media.currentTime;\n    }\n    /** Get the audio volume */\n    getVolume() {\n        return this.media.volume;\n    }\n    /** Set the audio volume */\n    setVolume(volume) {\n        this.media.volume = volume;\n    }\n    /** Get the audio muted state */\n    getMuted() {\n        return this.media.muted;\n    }\n    /** Mute or unmute the audio */\n    setMuted(muted) {\n        this.media.muted = muted;\n    }\n    /** Get the playback speed */\n    getPlaybackRate() {\n        return this.media.playbackRate;\n    }\n    /** Set the playback speed, pass an optional false to NOT preserve the pitch */\n    setPlaybackRate(rate, preservePitch) {\n        // preservePitch is true by default in most browsers\n        if (preservePitch != null) {\n            this.media.preservesPitch = preservePitch;\n        }\n        this.media.playbackRate = rate;\n    }\n    /** Get the HTML media element */\n    getMediaElement() {\n        return this.media;\n    }\n    /** Set a sink id to change the audio output device */\n    setSinkId(sinkId) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId\n        const media = this.media;\n        return media.setSinkId(sinkId);\n    }\n}\nexport default Player;\n", "export function makeDraggable(element, onDrag, onStart, onEnd, threshold = 5) {\n    let unsub = () => {\n        return;\n    };\n    if (!element)\n        return unsub;\n    const down = (e) => {\n        // Ignore the right mouse button\n        if (e.button === 2)\n            return;\n        e.preventDefault();\n        e.stopPropagation();\n        let startX = e.clientX;\n        let startY = e.clientY;\n        let isDragging = false;\n        const move = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const x = e.clientX;\n            const y = e.clientY;\n            if (isDragging || Math.abs(x - startX) >= threshold || Math.abs(y - startY) >= threshold) {\n                const { left, top } = element.getBoundingClientRect();\n                if (!isDragging) {\n                    isDragging = true;\n                    onStart === null || onStart === void 0 ? void 0 : onStart(startX - left, startY - top);\n                }\n                onDrag(x - startX, y - startY, x - left, y - top);\n                startX = x;\n                startY = y;\n            }\n        };\n        const click = (e) => {\n            if (isDragging) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        };\n        const up = () => {\n            if (isDragging) {\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n            }\n            unsub();\n        };\n        document.addEventListener('pointermove', move);\n        document.addEventListener('pointerup', up);\n        document.addEventListener('pointerleave', up);\n        document.addEventListener('click', click, true);\n        unsub = () => {\n            document.removeEventListener('pointermove', move);\n            document.removeEventListener('pointerup', up);\n            document.removeEventListener('pointerleave', up);\n            setTimeout(() => {\n                document.removeEventListener('click', click, true);\n            }, 10);\n        };\n    };\n    element.addEventListener('pointerdown', down);\n    return () => {\n        unsub();\n        element.removeEventListener('pointerdown', down);\n    };\n}\n", "import { makeDraggable } from './draggable.js';\nimport EventEmitter from './event-emitter.js';\nclass Renderer extends EventEmitter {\n    constructor(options, audioElement) {\n        super();\n        this.timeouts = [];\n        this.isScrolling = false;\n        this.audioData = null;\n        this.resizeObserver = null;\n        this.isDragging = false;\n        this.options = options;\n        let parent;\n        if (typeof options.container === 'string') {\n            parent = document.querySelector(options.container);\n        }\n        else if (options.container instanceof HTMLElement) {\n            parent = options.container;\n        }\n        if (!parent) {\n            throw new Error('Container not found');\n        }\n        this.parent = parent;\n        const [div, shadow] = this.initHtml();\n        parent.appendChild(div);\n        this.container = div;\n        this.scrollContainer = shadow.querySelector('.scroll');\n        this.wrapper = shadow.querySelector('.wrapper');\n        this.canvasWrapper = shadow.querySelector('.canvases');\n        this.progressWrapper = shadow.querySelector('.progress');\n        this.cursor = shadow.querySelector('.cursor');\n        if (audioElement) {\n            shadow.appendChild(audioElement);\n        }\n        this.initEvents();\n    }\n    initEvents() {\n        // Add a click listener\n        this.wrapper.addEventListener('click', (e) => {\n            const rect = this.wrapper.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const relativeX = x / rect.width;\n            this.emit('click', relativeX);\n        });\n        // Drag\n        this.initDrag();\n        // Add a scroll listener\n        this.scrollContainer.addEventListener('scroll', () => {\n            const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;\n            const startX = scrollLeft / scrollWidth;\n            const endX = (scrollLeft + clientWidth) / scrollWidth;\n            this.emit('scroll', startX, endX);\n        });\n        // Re-render the waveform on container resize\n        const delay = this.createDelay(100);\n        this.resizeObserver = new ResizeObserver(() => {\n            delay(() => this.reRender());\n        });\n        this.resizeObserver.observe(this.scrollContainer);\n    }\n    initDrag() {\n        makeDraggable(this.wrapper, \n        // On drag\n        (_, __, x) => {\n            this.emit('drag', Math.max(0, Math.min(1, x / this.wrapper.clientWidth)));\n        }, \n        // On start drag\n        () => (this.isDragging = true), \n        // On end drag\n        () => (this.isDragging = false));\n    }\n    getHeight() {\n        const defaultHeight = 128;\n        if (this.options.height == null)\n            return defaultHeight;\n        if (!isNaN(Number(this.options.height)))\n            return Number(this.options.height);\n        if (this.options.height === 'auto')\n            return this.parent.clientHeight || defaultHeight;\n        return defaultHeight;\n    }\n    initHtml() {\n        const div = document.createElement('div');\n        const shadow = div.attachShadow({ mode: 'open' });\n        shadow.innerHTML = `\n      <style>\n        :host {\n          user-select: none;\n        }\n        :host audio {\n          display: block;\n          width: 100%;\n        }\n        :host .scroll {\n          overflow-x: auto;\n          overflow-y: hidden;\n          width: 100%;\n          position: relative;\n          touch-action: none;\n        }\n        :host .noScrollbar {\n          scrollbar-color: transparent;\n          scrollbar-width: none;\n        }\n        :host .noScrollbar::-webkit-scrollbar {\n          display: none;\n          -webkit-appearance: none;\n        }\n        :host .wrapper {\n          position: relative;\n          overflow: visible;\n          z-index: 2;\n        }\n        :host .canvases {\n          min-height: ${this.getHeight()}px;\n        }\n        :host .canvases > div {\n          position: relative;\n        }\n        :host canvas {\n          display: block;\n          position: absolute;\n          top: 0;\n          image-rendering: pixelated;\n        }\n        :host .progress {\n          pointer-events: none;\n          position: absolute;\n          z-index: 2;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          overflow: hidden;\n        }\n        :host .progress > div {\n          position: relative;\n        }\n        :host .cursor {\n          pointer-events: none;\n          position: absolute;\n          z-index: 5;\n          top: 0;\n          left: 0;\n          height: 100%;\n          border-radius: 2px;\n        }\n      </style>\n\n      <div class=\"scroll\" part=\"scroll\">\n        <div class=\"wrapper\">\n          <div class=\"canvases\"></div>\n          <div class=\"progress\" part=\"progress\"></div>\n          <div class=\"cursor\" part=\"cursor\"></div>\n        </div>\n      </div>\n    `;\n        return [div, shadow];\n    }\n    setOptions(options) {\n        this.options = options;\n        // Re-render the waveform\n        this.reRender();\n    }\n    getWrapper() {\n        return this.wrapper;\n    }\n    getScroll() {\n        return this.scrollContainer.scrollLeft;\n    }\n    destroy() {\n        var _a;\n        this.container.remove();\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    createDelay(delayMs = 10) {\n        const context = {};\n        this.timeouts.push(context);\n        return (callback) => {\n            context.timeout && clearTimeout(context.timeout);\n            context.timeout = setTimeout(callback, delayMs);\n        };\n    }\n    // Convert array of color values to linear gradient\n    convertColorValues(color) {\n        if (!Array.isArray(color))\n            return color || '';\n        if (color.length < 2)\n            return color[0] || '';\n        const canvasElement = document.createElement('canvas');\n        const ctx = canvasElement.getContext('2d');\n        const gradient = ctx.createLinearGradient(0, 0, 0, canvasElement.height);\n        const colorStopPercentage = 1 / (color.length - 1);\n        color.forEach((color, index) => {\n            const offset = index * colorStopPercentage;\n            gradient.addColorStop(offset, color);\n        });\n        return gradient;\n    }\n    renderBarWaveform(channelData, options, ctx, vScale) {\n        const topChannel = channelData[0];\n        const bottomChannel = channelData[1] || channelData[0];\n        const length = topChannel.length;\n        const { width, height } = ctx.canvas;\n        const halfHeight = height / 2;\n        const pixelRatio = window.devicePixelRatio || 1;\n        const barWidth = options.barWidth ? options.barWidth * pixelRatio : 1;\n        const barGap = options.barGap ? options.barGap * pixelRatio : options.barWidth ? barWidth / 2 : 0;\n        const barRadius = options.barRadius || 0;\n        const barIndexScale = width / (barWidth + barGap) / length;\n        const rectFn = barRadius && 'roundRect' in ctx ? 'roundRect' : 'rect';\n        ctx.beginPath();\n        let prevX = 0;\n        let maxTop = 0;\n        let maxBottom = 0;\n        for (let i = 0; i <= length; i++) {\n            const x = Math.round(i * barIndexScale);\n            if (x > prevX) {\n                const topBarHeight = Math.round(maxTop * halfHeight * vScale);\n                const bottomBarHeight = Math.round(maxBottom * halfHeight * vScale);\n                const barHeight = topBarHeight + bottomBarHeight || 1;\n                // Vertical alignment\n                let y = halfHeight - topBarHeight;\n                if (options.barAlign === 'top') {\n                    y = 0;\n                }\n                else if (options.barAlign === 'bottom') {\n                    y = height - barHeight;\n                }\n                ctx[rectFn](prevX * (barWidth + barGap), y, barWidth, barHeight, barRadius);\n                prevX = x;\n                maxTop = 0;\n                maxBottom = 0;\n            }\n            const magnitudeTop = Math.abs(topChannel[i] || 0);\n            const magnitudeBottom = Math.abs(bottomChannel[i] || 0);\n            if (magnitudeTop > maxTop)\n                maxTop = magnitudeTop;\n            if (magnitudeBottom > maxBottom)\n                maxBottom = magnitudeBottom;\n        }\n        ctx.fill();\n        ctx.closePath();\n    }\n    renderLineWaveform(channelData, _options, ctx, vScale) {\n        const drawChannel = (index) => {\n            const channel = channelData[index] || channelData[0];\n            const length = channel.length;\n            const { height } = ctx.canvas;\n            const halfHeight = height / 2;\n            const hScale = ctx.canvas.width / length;\n            ctx.moveTo(0, halfHeight);\n            let prevX = 0;\n            let max = 0;\n            for (let i = 0; i <= length; i++) {\n                const x = Math.round(i * hScale);\n                if (x > prevX) {\n                    const h = Math.round(max * halfHeight * vScale) || 1;\n                    const y = halfHeight + h * (index === 0 ? -1 : 1);\n                    ctx.lineTo(prevX, y);\n                    prevX = x;\n                    max = 0;\n                }\n                const value = Math.abs(channel[i] || 0);\n                if (value > max)\n                    max = value;\n            }\n            ctx.lineTo(prevX, halfHeight);\n        };\n        ctx.beginPath();\n        drawChannel(0);\n        drawChannel(1);\n        ctx.fill();\n        ctx.closePath();\n    }\n    renderWaveform(channelData, options, ctx) {\n        ctx.fillStyle = this.convertColorValues(options.waveColor);\n        // Custom rendering function\n        if (options.renderFunction) {\n            options.renderFunction(channelData, ctx);\n            return;\n        }\n        // Vertical scaling\n        let vScale = options.barHeight || 1;\n        if (options.normalize) {\n            const max = Array.from(channelData[0]).reduce((max, value) => Math.max(max, Math.abs(value)), 0);\n            vScale = max ? 1 / max : 1;\n        }\n        // Render waveform as bars\n        if (options.barWidth || options.barGap || options.barAlign) {\n            this.renderBarWaveform(channelData, options, ctx, vScale);\n            return;\n        }\n        // Render waveform as a polyline\n        this.renderLineWaveform(channelData, options, ctx, vScale);\n    }\n    renderSingleCanvas(channelData, options, width, height, start, end, canvasContainer, progressContainer) {\n        const pixelRatio = window.devicePixelRatio || 1;\n        const canvas = document.createElement('canvas');\n        const length = channelData[0].length;\n        canvas.width = Math.round((width * (end - start)) / length);\n        canvas.height = height * pixelRatio;\n        canvas.style.width = `${Math.floor(canvas.width / pixelRatio)}px`;\n        canvas.style.height = `${height}px`;\n        canvas.style.left = `${Math.floor((start * width) / pixelRatio / length)}px`;\n        canvasContainer.appendChild(canvas);\n        const ctx = canvas.getContext('2d');\n        this.renderWaveform(channelData.map((channel) => channel.slice(start, end)), options, ctx);\n        // Draw a progress canvas\n        const progressCanvas = canvas.cloneNode();\n        progressContainer.appendChild(progressCanvas);\n        const progressCtx = progressCanvas.getContext('2d');\n        if (canvas.width > 0 && canvas.height > 0) {\n            progressCtx.drawImage(canvas, 0, 0);\n        }\n        // Set the composition method to draw only where the waveform is drawn\n        progressCtx.globalCompositeOperation = 'source-in';\n        progressCtx.fillStyle = this.convertColorValues(options.progressColor);\n        // This rectangle acts as a mask thanks to the composition method\n        progressCtx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    renderChannel(channelData, options, width) {\n        // A container for canvases\n        const canvasContainer = document.createElement('div');\n        const height = this.getHeight();\n        canvasContainer.style.height = `${height}px`;\n        this.canvasWrapper.style.minHeight = `${height}px`;\n        this.canvasWrapper.appendChild(canvasContainer);\n        // A container for progress canvases\n        const progressContainer = canvasContainer.cloneNode();\n        this.progressWrapper.appendChild(progressContainer);\n        // Determine the currently visible part of the waveform\n        const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;\n        const len = channelData[0].length;\n        const scale = len / scrollWidth;\n        let viewportWidth = Math.min(Renderer.MAX_CANVAS_WIDTH, clientWidth);\n        // Adjust width to avoid gaps between canvases when using bars\n        if (options.barWidth || options.barGap) {\n            const barWidth = options.barWidth || 0.5;\n            const barGap = options.barGap || barWidth / 2;\n            const totalBarWidth = barWidth + barGap;\n            if (viewportWidth % totalBarWidth !== 0) {\n                viewportWidth = Math.floor(viewportWidth / totalBarWidth) * totalBarWidth;\n            }\n        }\n        const start = Math.floor(Math.abs(scrollLeft) * scale);\n        const end = Math.floor(start + viewportWidth * scale);\n        const viewportLen = end - start;\n        // Draw a portion of the waveform from start peak to end peak\n        const draw = (start, end) => {\n            this.renderSingleCanvas(channelData, options, width, height, Math.max(0, start), Math.min(end, len), canvasContainer, progressContainer);\n        };\n        // Draw the waveform in viewport chunks, each with a delay\n        const headDelay = this.createDelay();\n        const tailDelay = this.createDelay();\n        const renderHead = (fromIndex, toIndex) => {\n            draw(fromIndex, toIndex);\n            if (fromIndex > 0) {\n                headDelay(() => {\n                    renderHead(fromIndex - viewportLen, toIndex - viewportLen);\n                });\n            }\n        };\n        const renderTail = (fromIndex, toIndex) => {\n            draw(fromIndex, toIndex);\n            if (toIndex < len) {\n                tailDelay(() => {\n                    renderTail(fromIndex + viewportLen, toIndex + viewportLen);\n                });\n            }\n        };\n        renderHead(start, end);\n        if (end < len) {\n            renderTail(end, end + viewportLen);\n        }\n    }\n    render(audioData) {\n        // Clear previous timeouts\n        this.timeouts.forEach((context) => context.timeout && clearTimeout(context.timeout));\n        this.timeouts = [];\n        // Clear the canvases\n        this.canvasWrapper.innerHTML = '';\n        this.progressWrapper.innerHTML = '';\n        this.wrapper.style.width = '';\n        // Determine the width of the waveform\n        const pixelRatio = window.devicePixelRatio || 1;\n        const parentWidth = this.scrollContainer.clientWidth;\n        const scrollWidth = Math.ceil(audioData.duration * (this.options.minPxPerSec || 0));\n        // Whether the container should scroll\n        this.isScrolling = scrollWidth > parentWidth;\n        const useParentWidth = this.options.fillParent && !this.isScrolling;\n        // Width of the waveform in pixels\n        const width = (useParentWidth ? parentWidth : scrollWidth) * pixelRatio;\n        // Set the width of the wrapper\n        this.wrapper.style.width = useParentWidth ? '100%' : `${scrollWidth}px`;\n        // Set additional styles\n        this.scrollContainer.style.overflowX = this.isScrolling ? 'auto' : 'hidden';\n        this.scrollContainer.classList.toggle('noScrollbar', !!this.options.hideScrollbar);\n        this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`;\n        this.cursor.style.width = `${this.options.cursorWidth}px`;\n        // Render the waveform\n        if (this.options.splitChannels) {\n            // Render a waveform for each channel\n            for (let i = 0; i < audioData.numberOfChannels; i++) {\n                const options = Object.assign(Object.assign({}, this.options), this.options.splitChannels[i]);\n                this.renderChannel([audioData.getChannelData(i)], options, width);\n            }\n        }\n        else {\n            // Render a single waveform for the first two channels (left and right)\n            const channels = [audioData.getChannelData(0)];\n            if (audioData.numberOfChannels > 1)\n                channels.push(audioData.getChannelData(1));\n            this.renderChannel(channels, this.options, width);\n        }\n        this.audioData = audioData;\n        this.emit('render');\n    }\n    reRender() {\n        // Return if the waveform has not been rendered yet\n        if (!this.audioData)\n            return;\n        // Remember the current cursor position\n        const oldCursorPosition = this.progressWrapper.clientWidth;\n        // Set the new zoom level and re-render the waveform\n        this.render(this.audioData);\n        // Adjust the scroll position so that the cursor stays in the same place\n        const newCursortPosition = this.progressWrapper.clientWidth;\n        this.scrollContainer.scrollLeft += newCursortPosition - oldCursorPosition;\n    }\n    zoom(minPxPerSec) {\n        this.options.minPxPerSec = minPxPerSec;\n        this.reRender();\n    }\n    scrollIntoView(progress, isPlaying = false) {\n        const { clientWidth, scrollLeft, scrollWidth } = this.scrollContainer;\n        const progressWidth = scrollWidth * progress;\n        const center = clientWidth / 2;\n        const minScroll = isPlaying && this.options.autoCenter && !this.isDragging ? center : clientWidth;\n        if (progressWidth > scrollLeft + minScroll || progressWidth < scrollLeft) {\n            // Scroll to the center\n            if (this.options.autoCenter && !this.isDragging) {\n                // If the cursor is in viewport but not centered, scroll to the center slowly\n                const minDiff = center / 20;\n                if (progressWidth - (scrollLeft + center) >= minDiff && progressWidth < scrollLeft + clientWidth) {\n                    this.scrollContainer.scrollLeft += minDiff;\n                }\n                else {\n                    // Otherwise, scroll to the center immediately\n                    this.scrollContainer.scrollLeft = progressWidth - center;\n                }\n            }\n            else if (this.isDragging) {\n                // Scroll just a little bit to allow for some space between the cursor and the edge\n                const gap = 10;\n                this.scrollContainer.scrollLeft =\n                    progressWidth < scrollLeft ? progressWidth - gap : progressWidth - clientWidth + gap;\n            }\n            else {\n                // Scroll to the beginning\n                this.scrollContainer.scrollLeft = progressWidth;\n            }\n        }\n        // Emit the scroll event\n        {\n            const { scrollLeft } = this.scrollContainer;\n            const startX = scrollLeft / scrollWidth;\n            const endX = (scrollLeft + clientWidth) / scrollWidth;\n            this.emit('scroll', startX, endX);\n        }\n    }\n    renderProgress(progress, isPlaying) {\n        if (isNaN(progress))\n            return;\n        this.progressWrapper.style.width = `${progress * 100}%`;\n        this.cursor.style.left = `${progress * 100}%`;\n        this.cursor.style.marginLeft = Math.round(progress * 100) === 100 ? `-${this.options.cursorWidth}px` : '';\n        if (this.isScrolling && this.options.autoScroll) {\n            this.scrollIntoView(progress, isPlaying);\n        }\n    }\n}\nRenderer.MAX_CANVAS_WIDTH = 4000;\nexport default Renderer;\n", "import EventEmitter from './event-emitter.js';\nclass Timer extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.unsubscribe = () => undefined;\n    }\n    start() {\n        this.unsubscribe = this.on('tick', () => {\n            requestAnimationFrame(() => {\n                this.emit('tick');\n            });\n        });\n        this.emit('tick');\n    }\n    stop() {\n        this.unsubscribe();\n    }\n    destroy() {\n        this.unsubscribe();\n    }\n}\nexport default Timer;\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Decoder from './decoder.js';\nimport Fetcher from './fetcher.js';\nimport Player from './player.js';\nimport Renderer from './renderer.js';\nimport Timer from './timer.js';\nconst defaultOptions = {\n    waveColor: '#999',\n    progressColor: '#555',\n    cursorWidth: 1,\n    minPxPerSec: 0,\n    fillParent: true,\n    interact: true,\n    autoScroll: true,\n    autoCenter: true,\n    sampleRate: 8000,\n};\nclass WaveSurfer extends Player {\n    /** Create a new WaveSurfer instance */\n    static create(options) {\n        return new WaveSurfer(options);\n    }\n    /** Create a new WaveSurfer instance */\n    constructor(options) {\n        var _a, _b;\n        super({\n            media: options.media,\n            mediaControls: options.mediaControls,\n            autoplay: options.autoplay,\n            playbackRate: options.audioRate,\n        });\n        this.plugins = [];\n        this.decodedData = null;\n        this.subscriptions = [];\n        this.options = Object.assign({}, defaultOptions, options);\n        this.timer = new Timer();\n        const audioElement = !options.media ? this.getMediaElement() : undefined;\n        this.renderer = new Renderer(this.options, audioElement);\n        this.initPlayerEvents();\n        this.initRendererEvents();\n        this.initTimerEvents();\n        this.initPlugins();\n        // Load audio if URL is passed or an external media with an src\n        const url = this.options.url || ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.currentSrc) || ((_b = this.options.media) === null || _b === void 0 ? void 0 : _b.src);\n        if (url) {\n            this.load(url, this.options.peaks, this.options.duration);\n        }\n    }\n    initTimerEvents() {\n        // The timer fires every 16ms for a smooth progress animation\n        this.subscriptions.push(this.timer.on('tick', () => {\n            const currentTime = this.getCurrentTime();\n            this.renderer.renderProgress(currentTime / this.getDuration(), true);\n            this.emit('timeupdate', currentTime);\n            this.emit('audioprocess', currentTime);\n        }));\n    }\n    initPlayerEvents() {\n        this.subscriptions.push(this.onMediaEvent('timeupdate', () => {\n            const currentTime = this.getCurrentTime();\n            this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying());\n            this.emit('timeupdate', currentTime);\n        }), this.onMediaEvent('play', () => {\n            this.emit('play');\n            this.timer.start();\n        }), this.onMediaEvent('pause', () => {\n            this.emit('pause');\n            this.timer.stop();\n        }), this.onMediaEvent('emptied', () => {\n            this.timer.stop();\n        }), this.onMediaEvent('ended', () => {\n            this.emit('finish');\n        }), this.onMediaEvent('seeking', () => {\n            this.emit('seeking', this.getCurrentTime());\n        }));\n    }\n    initRendererEvents() {\n        this.subscriptions.push(\n        // Seek on click\n        this.renderer.on('click', (relativeX) => {\n            if (this.options.interact) {\n                this.seekTo(relativeX);\n                this.emit('interaction', relativeX * this.getDuration());\n                this.emit('click', relativeX);\n            }\n        }), \n        // Scroll\n        this.renderer.on('scroll', (startX, endX) => {\n            const duration = this.getDuration();\n            this.emit('scroll', startX * duration, endX * duration);\n        }), \n        // Redraw\n        this.renderer.on('render', () => {\n            this.emit('redraw');\n        }));\n        // Drag\n        {\n            let debounce;\n            this.subscriptions.push(this.renderer.on('drag', (relativeX) => {\n                if (!this.options.interact)\n                    return;\n                // Update the visual position\n                this.renderer.renderProgress(relativeX);\n                // Set the audio position with a debounce\n                clearTimeout(debounce);\n                debounce = setTimeout(() => {\n                    this.seekTo(relativeX);\n                }, this.isPlaying() ? 0 : 200);\n                this.emit('interaction', relativeX * this.getDuration());\n                this.emit('drag', relativeX);\n            }));\n        }\n    }\n    initPlugins() {\n        var _a;\n        if (!((_a = this.options.plugins) === null || _a === void 0 ? void 0 : _a.length))\n            return;\n        this.options.plugins.forEach((plugin) => {\n            this.registerPlugin(plugin);\n        });\n    }\n    /** Set new wavesurfer options and re-render it */\n    setOptions(options) {\n        this.options = Object.assign({}, this.options, options);\n        this.renderer.setOptions(this.options);\n        if (options.audioRate) {\n            this.setPlaybackRate(options.audioRate);\n        }\n        if (options.mediaControls != null) {\n            this.getMediaElement().controls = options.mediaControls;\n        }\n    }\n    /** Register a wavesurfer.js plugin */\n    registerPlugin(plugin) {\n        plugin.init(this);\n        this.plugins.push(plugin);\n        // Unregister plugin on destroy\n        this.subscriptions.push(plugin.once('destroy', () => {\n            this.plugins = this.plugins.filter((p) => p !== plugin);\n        }));\n        return plugin;\n    }\n    /** For plugins only: get the waveform wrapper div */\n    getWrapper() {\n        return this.renderer.getWrapper();\n    }\n    /** Get the current scroll position in pixels */\n    getScroll() {\n        return this.renderer.getScroll();\n    }\n    /** Get all registered plugins */\n    getActivePlugins() {\n        return this.plugins;\n    }\n    loadAudio(url, blob, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.emit('load', url);\n            if (this.isPlaying())\n                this.pause();\n            this.decodedData = null;\n            // Fetch the entire audio as a blob if pre-decoded data is not provided\n            if (!blob && !channelData) {\n                const onProgress = (percentage) => this.emit('loading', percentage);\n                blob = yield Fetcher.fetchBlob(url, onProgress, this.options.fetchParams);\n            }\n            // Set the mediaelement source\n            this.setSrc(url, blob);\n            // Decode the audio data or use user-provided peaks\n            if (channelData) {\n                // Wait for the audio duration\n                // It should be a promise to allow event listeners to subscribe to the ready and decode events\n                duration =\n                    (yield Promise.resolve(duration || this.getDuration())) ||\n                        (yield new Promise((resolve) => {\n                            this.onceMediaEvent('loadedmetadata', () => resolve(this.getDuration()));\n                        })) ||\n                        (yield Promise.resolve(0));\n                this.decodedData = Decoder.createBuffer(channelData, duration);\n            }\n            else if (blob) {\n                const arrayBuffer = yield blob.arrayBuffer();\n                this.decodedData = yield Decoder.decode(arrayBuffer, this.options.sampleRate);\n            }\n            this.emit('decode', this.getDuration());\n            // Render the waveform\n            if (this.decodedData) {\n                this.renderer.render(this.decodedData);\n            }\n            this.emit('ready', this.getDuration());\n        });\n    }\n    /** Load an audio file by URL, with optional pre-decoded audio data */\n    load(url, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadAudio(url, undefined, channelData, duration);\n        });\n    }\n    /** Load an audio blob */\n    loadBlob(blob, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadAudio('blob', blob, channelData, duration);\n        });\n    }\n    /** Zoom the waveform by a given pixels-per-second factor */\n    zoom(minPxPerSec) {\n        if (!this.decodedData) {\n            throw new Error('No audio loaded');\n        }\n        this.renderer.zoom(minPxPerSec);\n        this.emit('zoom', minPxPerSec);\n    }\n    /** Get the decoded audio data */\n    getDecodedData() {\n        return this.decodedData;\n    }\n    /** Get decoded peaks */\n    exportPeaks({ channels = 1, maxLength = 8000, precision = 10000 } = {}) {\n        if (!this.decodedData) {\n            throw new Error('The audio has not been decoded yet');\n        }\n        const channelsLen = Math.min(channels, this.decodedData.numberOfChannels);\n        const peaks = [];\n        for (let i = 0; i < channelsLen; i++) {\n            const data = this.decodedData.getChannelData(i);\n            const length = Math.min(data.length, maxLength);\n            const scale = data.length / length;\n            const sampledData = [];\n            for (let j = 0; j < length; j++) {\n                const n = Math.round(j * scale);\n                const val = data[n];\n                sampledData.push(Math.round(val * precision) / precision);\n            }\n            peaks.push(sampledData);\n        }\n        return peaks;\n    }\n    /** Get the duration of the audio in seconds */\n    getDuration() {\n        let duration = super.getDuration() || 0;\n        // Fall back to the decoded data duration if the media duration is incorrect\n        if ((duration === 0 || duration === Infinity) && this.decodedData) {\n            duration = this.decodedData.duration;\n        }\n        return duration;\n    }\n    /** Toggle if the waveform should react to clicks */\n    toggleInteraction(isInteractive) {\n        this.options.interact = isInteractive;\n    }\n    /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */\n    seekTo(progress) {\n        const time = this.getDuration() * progress;\n        this.setTime(time);\n    }\n    /** Play or pause the audio */\n    playPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.isPlaying() ? this.pause() : this.play();\n        });\n    }\n    /** Stop the audio and go to the beginning */\n    stop() {\n        this.pause();\n        this.setTime(0);\n    }\n    /** Skip N or -N seconds from the current position */\n    skip(seconds) {\n        this.setTime(this.getCurrentTime() + seconds);\n    }\n    /** Empty the waveform by loading a tiny silent audio */\n    empty() {\n        this.load('', [[0]], 0.001);\n    }\n    /** Unmount wavesurfer */\n    destroy() {\n        this.emit('destroy');\n        this.plugins.forEach((plugin) => plugin.destroy());\n        this.subscriptions.forEach((unsubscribe) => unsubscribe());\n        this.timer.destroy();\n        this.renderer.destroy();\n        super.destroy();\n    }\n}\nexport default WaveSurfer;\n"],
  "mappings": "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",
  "names": ["decode", "__awaiter", "done", "value", "e", "color", "max", "start", "end", "scrollLeft", "__awaiter"]
}
